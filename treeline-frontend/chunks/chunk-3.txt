================================================================================
CHUNK 4 OF 5
================================================================================

========================================
File: ./src/components/ImpactAnalysis.tsx
========================================
import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';
import { CodeLink } from '../types';

interface ImpactAnalysisProps {
  nodeId: string;
  nodeName: string;
  nodeType: string;
  connections: {
    incoming: CodeLink[];
    outgoing: CodeLink[];
  };
  hasIssues: boolean;
  highComplexity: boolean;
}

const ImpactAnalysis: React.FC<ImpactAnalysisProps> = ({
  nodeId,
  nodeName,
  nodeType,
  connections,
  hasIssues,
  highComplexity,
}) => {
  const svgRef = useRef<SVGSVGElement>(null);

  useEffect(() => {
    if (!svgRef.current) return;

    d3.select(svgRef.current).selectAll('*').remove();

    const width = 600;
    const height = 400;

    const svg = d3.select(svgRef.current)
      .attr('width', width)
      .attr('height', height);

    const nodes: any[] = [];
    const links: any[] = [];
    
    const addedNodes = new Set<string>([nodeId]);
    const secondaryNodes = new Set<string>();
    
    nodes.push({
      id: nodeId,
      name: nodeName,
      type: nodeType,
      level: 0,
      isCenter: true,
      hasIssues,
      highComplexity
    });
    connections.incoming.forEach(connection => {
      const sourceId = typeof connection.source === 'object' ? connection.source.id : connection.source;
      const sourceName = typeof connection.source === 'object' ? connection.source.name : `Node ${sourceId}`;
      const sourceType = typeof connection.source === 'object' ? connection.source.type : 'unknown';
      
      if (!addedNodes.has(sourceId)) {
        nodes.push({
          id: sourceId,
          name: sourceName,
          type: sourceType,
          level: 1,
          direction: 'incoming'
        });
        addedNodes.add(sourceId);
        secondaryNodes.add(sourceId);
      }
      
      links.push({
        source: sourceId,
        target: nodeId,
        type: connection.type,
        direction: 'incoming'
      });
    });
    
    connections.outgoing.forEach(connection => {
      const targetId = typeof connection.target === 'object' ? connection.target.id : connection.target;
      const targetName = typeof connection.target === 'object' ? connection.target.name : `Node ${targetId}`;
      const targetType = typeof connection.target === 'object' ? connection.target.type : 'unknown';
      
      if (!addedNodes.has(targetId)) {
        nodes.push({
          id: targetId,
          name: targetName,
          type: targetType,
          level: 1,
          direction: 'outgoing'
        });
        addedNodes.add(targetId);
        secondaryNodes.add(targetId);
      }
      
      links.push({
        source: nodeId,
        target: targetId,
        type: connection.type,
        direction: 'outgoing'
      });
    });
    

    const impactScores = new Map<string, number>();
    
    impactScores.set(nodeId, 10);
    
    nodes.forEach(node => {
      if (node.id === nodeId) return;
      
      let score = 5;
      
      const directConnections = links.filter(link => 
        link.source === node.id || link.target === node.id
      );
      
      directConnections.forEach(link => {
        if (link.type === 'contains') score += 3;
        else if (link.type === 'imports') score += 2;
        else if (link.type === 'calls') score += 1;
      });
      
      if (node.type === 'module') score += 3;
      else if (node.type === 'class') score += 2;
      else if (node.type === 'function') score += 1;
      
      score = Math.min(10, Math.max(0, score));
      
      impactScores.set(node.id, score);
    });
    
    const simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links).id((d: any) => d.id).distance(80))
      .force('charge', d3.forceManyBody().strength(-300))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius(30));
    
    const defs = svg.append('defs');
    ['imports', 'contains', 'calls'].forEach(type => {
      defs.append('marker')
        .attr('id', `impact-arrow-${type}`)
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 20)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('fill', type === 'imports' ? '#7c3aed' : type === 'contains' ? '#059669' : '#ea580c')
        .attr('d', 'M0,-5L10,0L0,5');
    });
    
    const link = svg.append('g')
      .selectAll('path')
      .data(links)
      .enter()
      .append('path')
      .attr('stroke', d => {
        if (d.type === 'imports') return '#7c3aed';
        if (d.type === 'contains') return '#059669';
        return '#ea580c';
      })
      .attr('stroke-width', d => {
        if (d.source === nodeId || d.target === nodeId) return 2;
        return 1.5;
      })
      .attr('stroke-opacity', d => {
        if (d.source === nodeId || d.target === nodeId) return 0.8;
        return 0.6;
      })
      .attr('marker-end', d => `url(#impact-arrow-${d.type})`)
      .attr('fill', 'none');
    
    const node = svg.append('g')
      .selectAll('.node')
      .data(nodes)
      .enter()
      .append('g')
      .attr('class', 'node')
      .call(d3.drag<any, any>()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended));
    
    node.append('circle')
      .attr('r', d => {
        if (d.isCenter) return 15;
        return 10;
      })
      .attr('fill', d => {
        if (d.isCenter) return highComplexity ? '#ef4444' : (hasIssues ? '#f59e0b' : '#3b82f6');
        if (d.type === 'module') return '#93c5fd';
        if (d.type === 'class') return '#67e8f9';
        if (d.type === 'function') return '#6ee7b7';
        return '#d1d5db';
      })
      .attr('stroke', d => {
        if (d.isCenter) return '#3b82f6';
        if (d.type === 'module') return '#1d4ed8';
        if (d.type === 'class') return '#0e7490';
        if (d.type === 'function') return '#047857';
        return '#6b7280';
      })
      .attr('stroke-width', d => d.isCenter ? 3 : 1.5);
    
    node.append('circle')
      .attr('r', d => {
        const score = impactScores.get(d.id) || 0;
        return score * 2; 
      })
      .attr('fill', 'none')
      .attr('stroke', d => {
        const score = impactScores.get(d.id) || 0;
        if (score >= 7) return '#ef4444';
        if (score >= 4) return '#f59e0b';
        return '#10b981';
      })
      .attr('stroke-width', 1.5)
      .attr('stroke-dasharray', '3,3')
      .attr('stroke-opacity', 0.7);
    
    node.append('text')
      .attr('dx', 15)
      .attr('dy', 5)
      .text(d => d.name)
      .attr('font-size', d => d.isCenter ? '14px' : '12px')
      .attr('font-weight', d => d.isCenter ? 'bold' : 'normal');
    
    node.select('text')
      .each(function() {
        const textElement = this as SVGTextElement;
        const bbox = textElement.getBBox();
        
        const parent = textElement.parentNode as SVGGElement;
        d3.select(parent)
          .insert('rect', 'text')
          .attr('x', bbox.x - 2)
          .attr('y', bbox.y - 2)
          .attr('width', bbox.width + 4)
          .attr('height', bbox.height + 4)
          .attr('fill', 'white')
          .attr('fill-opacity', 0.8)
          .attr('rx', 3);
      });
    
    node.append('title')
      .text(d => {
        const score = impactScores.get(d.id) || 0;
        return `${d.name} (${d.type})\nImpact Score: ${score.toFixed(1)}/10`;
      });
    
    simulation.on('tick', () => {
      link.attr('d', d => {
        const dx = d.target.x - d.source.x;
        const dy = d.target.y - d.source.y;
        const dr = Math.sqrt(dx * dx + dy * dy);
        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
      });
      
      node.attr('transform', d => `translate(${d.x},${d.y})`);
    });
    
    const legend = svg.append('g')
      .attr('transform', `translate(10, 20)`);
    
    legend.append('text')
      .attr('x', 0)
      .attr('y', 0)
      .text('Impact Analysis')
      .attr('font-size', '16px')
      .attr('font-weight', 'bold');
    
    const legendItems = [
      { color: '#3b82f6', label: 'Current Node' },
      { color: '#ef4444', label: 'High Impact' },
      { color: '#f59e0b', label: 'Medium Impact' },
      { color: '#10b981', label: 'Low Impact' }
    ];
    
    legendItems.forEach((item, i) => {
      legend.append('rect')
        .attr('x', 0)
        .attr('y', 25 + i * 20)
        .attr('width', 15)
        .attr('height', 15)
        .attr('fill', item.color);
      
      legend.append('text')
        .attr('x', 25)
        .attr('y', 25 + i * 20 + 12)
        .text(item.label)
        .attr('font-size', '12px');
    });
    
    function dragstarted(event: any, d: any) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }
    
    function dragged(event: any, d: any) {
      d.fx = event.x;
      d.fy = event.y;
    }
    
    function dragended(event: any, d: any) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }
  }, [nodeId, nodeName, nodeType, connections, hasIssues, highComplexity]);

  return (
    <div className="impact-analysis">
      <svg ref={svgRef}></svg>
      <div className="mt-4 text-sm text-gray-600">
        <p>This visualization shows the potential impact of changes to this component on other parts of the codebase.</p>
        <p>Larger dotted circles indicate higher potential impact. Nodes can be dragged to rearrange the visualization.</p>
      </div>
    </div>
  );
};

export default ImpactAnalysis;
========================================
File: ./node_modules/flatted/python/flatted.py
========================================
# ISC License
#
# Copyright (c) 2018-2025, Andrea Giammarchi, @WebReflection
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
# OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

import json as _json

class _Known:
    def __init__(self):
        self.key = []
        self.value = []

class _String:
    def __init__(self, value):
        self.value = value


def _array_keys(value):
    keys = []
    i = 0
    for _ in value:
        keys.append(i)
        i += 1
    return keys

def _object_keys(value):
    keys = []
    for key in value:
        keys.append(key)
    return keys

def _is_array(value):
    return isinstance(value, (list, tuple))

def _is_object(value):
    return isinstance(value, dict)

def _is_string(value):
    return isinstance(value, str)

def _index(known, input, value):
    input.append(value)
    index = str(len(input) - 1)
    known.key.append(value)
    known.value.append(index)
    return index

def _loop(keys, input, known, output):
    for key in keys:
        value = output[key]
        if isinstance(value, _String):
            _ref(key, input[int(value.value)], input, known, output)

    return output

def _ref(key, value, input, known, output):
    if _is_array(value) and value not in known:
        known.append(value)
        value = _loop(_array_keys(value), input, known, value)
    elif _is_object(value) and value not in known:
        known.append(value)
        value = _loop(_object_keys(value), input, known, value)

    output[key] = value

def _relate(known, input, value):
    if _is_string(value) or _is_array(value) or _is_object(value):
        try:
            return known.value[known.key.index(value)]
        except:
            return _index(known, input, value)

    return value

def _transform(known, input, value):
    if _is_array(value):
        output = []
        for val in value:
            output.append(_relate(known, input, val))
        return output

    if _is_object(value):
        obj = {}
        for key in value:
            obj[key] = _relate(known, input, value[key])
        return obj

    return value

def _wrap(value):
    if _is_string(value):
        return _String(value)

    if _is_array(value):
        i = 0
        for val in value:
            value[i] = _wrap(val)
            i += 1

    elif _is_object(value):
        for key in value:
            value[key] = _wrap(value[key])

    return value

def parse(value, *args, **kwargs):
    json = _json.loads(value, *args, **kwargs)
    wrapped = []
    for value in json:
        wrapped.append(_wrap(value))

    input = []
    for value in wrapped:
        if isinstance(value, _String):
            input.append(value.value)
        else:
            input.append(value)

    value = input[0]

    if _is_array(value):
        return _loop(_array_keys(value), input, [value], value)

    if _is_object(value):
        return _loop(_object_keys(value), input, [value], value)

    return value


def stringify(value, *args, **kwargs):
    known = _Known()
    input = []
    output = []
    i = int(_index(known, input, value))
    while i < len(input):
        output.append(_transform(known, input, input[i]))
        i += 1
    return _json.dumps(output, *args, **kwargs)

========================================
File: ./README.md
========================================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```

========================================
File: ./src/components/NodeConnections.tsx
========================================
import React from 'react';
import { Link } from 'react-router-dom';
import { CodeLink } from '../types';

interface NodeConnectionsProps {
  incoming: CodeLink[];
  outgoing: CodeLink[];
}

const NodeConnections: React.FC<NodeConnectionsProps> = ({ incoming, outgoing }) => {
  const getNodeName = (link: CodeLink, isSource: boolean): string => {
    const node = isSource ? link.source : link.target;
    return typeof node === 'object' ? node.name : node;
  };
  
  const getNodeId = (link: CodeLink, isSource: boolean): string => {
    const node = isSource ? link.source : link.target;
    return typeof node === 'object' ? node.id : node;
  };
  
  const renderConnectionList = (links: CodeLink[], isIncoming: boolean) => {
    if (links.length === 0) return null;
    
    return (
      <div className="connection-group">
        <h4>{isIncoming ? 'Incoming' : 'Outgoing'} ({links.length})</h4>
        <ul className="connection-list">
          {links.map((link, index) => (
            <li key={index}>
              <span className={`link-type ${link.type}`}>{link.type}</span>
              {isIncoming ? 'from' : 'to'} <Link to={`/node/${getNodeId(link, isIncoming)}`}>
                <strong>{getNodeName(link, isIncoming)}</strong>
              </Link>
            </li>
          ))}
        </ul>
      </div>
    );
  };
  
  return (
    <div className="connections-section">
      <h3>ðŸ”„ Dependencies</h3>
      {renderConnectionList(incoming, true)}
      {renderConnectionList(outgoing, false)}
    </div>
  );
};

export default NodeConnections;
========================================
File: ./src/components/Legend.tsx
========================================
import React from 'react';

const Legend: React.FC = () => {
  return (
    <div className="legend p-4 bg-white shadow-md rounded-lg">
      <h3 className="text-lg font-bold mb-2">Legend</h3>
      <h3 className="text-red-500">Legend</h3>
      <h3 className="text-red-500">Legend</h3>

      <div className="space-y-2">
        <div className="flex items-center">
          <div className="legend-color module-color mr-2"></div>
          <span>Module</span>
        </div>
        <div className="flex items-center">
          <div className="legend-color entry-point-color mr-2"></div>
          <span>Entry Point</span>
        </div>
        <div className="flex items-center">
          <div className="legend-color class-color mr-2"></div>
          <span>Class</span>
        </div>
        <div className="flex items-center">
          <div className="legend-color function-color mr-2"></div>
          <span>Function</span>
        </div>
        <div className="mt-4 space-y-2">
          <div className="flex items-center">
            <div className="legend-line imports-line mr-2"></div>
            <span>Imports</span>
          </div>
          <div className="flex items-center">
            <div className="legend-line contains-line mr-2"></div>
            <span>Contains</span>
          </div>
          <div className="flex items-center">
            <div className="legend-line calls-line mr-2"></div>
            <span>Calls</span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Legend;
========================================
File: ./package.json
========================================
{
  "name": "treeline-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@types/d3": "^7.4.3",
    "d3": "^7.9.0",
    "lodash": "^4.17.21",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-router-dom": "^7.2.0",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.21.0",
    "@types/lodash": "^4.17.16",
    "@types/node": "^22.13.8",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.21.0",
    "eslint-plugin-react-hooks": "^5.1.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^15.15.0",
    "postcss": "^8.5.3",
    "tailwindcss": "^3.4.17",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.24.1",
    "vite": "^6.2.0"
  }
}

========================================
File: ./src/App.tsx
========================================
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import VisualizationPage from './page/VisualizationPage';
import NodeDetailsPage from './page/NodeDetailsPage';

const App: React.FC = () => {
  return (
    <Router>
      <Routes>
        <Route path="/" element={<VisualizationPage />} />
        <Route path="/node/:nodeId" element={<NodeDetailsPage />} />
        <Route path="*" element={<div>Not Found</div>} />
      </Routes>
    </Router>
  );
};

export default App;
========================================
File: ./tsconfig.node.json
========================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

========================================
File: ./postcss.config.cjs
========================================
module.exports = {
    plugins: {
      tailwindcss: {},
      autoprefixer: {},
    }
  }
