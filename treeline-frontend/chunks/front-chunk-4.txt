================================================================================
CHUNK 5 OF 5
================================================================================

========================================
File: ./src/services/dataServices.ts
========================================
import { GraphData } from '../types';

const API_BASE_URL = 'http://localhost:8000';

export interface GraphDataParams {
  limit?: number;
  offset?: number;
  minConnections?: number;
  types?: string[];
  searchTerm?: string;
  includeEntryPointsOnly?: boolean;
}

export async function fetchGraphData(params: GraphDataParams = {}): Promise<GraphData> {
  try {
    const queryParams = new URLSearchParams();
    
    if (params.limit) queryParams.append('limit', params.limit.toString());
    if (params.offset) queryParams.append('offset', params.offset.toString());
    if (params.minConnections) queryParams.append('min_connections', params.minConnections.toString());
    if (params.types && params.types.length > 0) {
      params.types.forEach(type => queryParams.append('type', type));
    }
    if (params.searchTerm) queryParams.append('search', params.searchTerm);
    if (params.includeEntryPointsOnly) queryParams.append('entry_points_only', 'true');
    
    const queryString = queryParams.toString();
    const url = `${API_BASE_URL}/api/graph-data${queryString ? `?${queryString}` : ''}`;
    
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching graph data:', error);
    throw error;
  }
}

export async function fetchNodeData(nodeId: string): Promise<any> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/node/${nodeId}`);
    
    if (!response.ok) {
      if (response.status === 404) {
        const errorData = await response.json();
        throw new Error(`Node not found: ${errorData.detail || 'The requested node does not exist'}`);
      }
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error(`Error fetching data for node ${nodeId}:`, error);
    throw error;
  }
}

export async function fetchNodeConnections(nodeId: string, depth: number = 1): Promise<any> {
  try {
    const response = await fetch(
      `${API_BASE_URL}/api/node/${nodeId}/connections?depth=${depth}`
    );
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error(`Error fetching connections for node ${nodeId}:`, error);
    throw error;
  }
}

export async function fetchGraphSummary(): Promise<any> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/graph-summary`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching graph summary:', error);
    throw error;
  }
}

export async function searchNodes(query: string, limit: number = 20): Promise<any[]> {
  try {
    const response = await fetch(
      `${API_BASE_URL}/api/search?q=${encodeURIComponent(query)}&limit=${limit}`
    );
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error searching nodes:', error);
    throw error;
  }
}

export async function fetchDetailedMetrics(): Promise<any> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/detailed-metrics`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching detailed metrics:', error);
    throw error;
  }
}

export async function fetchFileDetailedMetrics(filePath: string): Promise<any> {
    if (!filePath || filePath === 'unknown') {
      console.warn('Skipping fetch for invalid file path:', filePath);
      return null;
    }
    try {
      const encodedPath = encodeURIComponent(filePath);
      const response = await fetch(`${API_BASE_URL}/api/detailed-metrics/file/${encodedPath}`);
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      return await response.json();
    } catch (error) {
      console.error(`Error fetching detailed metrics for file ${filePath}:`, error);
      throw error;
    }
  }

export async function fetchComplexityBreakdown(byFile: boolean = false): Promise<any> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/detailed-metrics/complexity-breakdown?by_file=${byFile}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching complexity breakdown:', error);
    throw error;
  }
}

export async function fetchIssuesByCategory(): Promise<any> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/detailed-metrics/issues-by-category`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching issues by category:', error);
    throw error;
  }
}

export async function fetchDetailedDependencyGraph(includeDetails: boolean = true): Promise<any> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/detailed-metrics/dependency-graph?include_details=${includeDetails}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching detailed dependency graph:', error);
    throw error;
  }
}

export async function fetchMetricsThresholds(): Promise<any> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/metrics/thresholds`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching metrics thresholds:', error);
    throw error;
  }
}

/**
 * Helper function to get issue category from smell
 */
function getIssueCategory(smell: any): string {
  if (typeof smell === 'string') {
    if (smell.startsWith('[')) {
      const endIndex = smell.indexOf(']', 1);
      if (endIndex !== -1) {
        return smell.slice(1, endIndex).toLowerCase();
      }
    }
    if (smell.toLowerCase().includes('security')) return 'security';
    if (smell.toLowerCase().includes('sql injection')) return 'sql_injection';
    if (smell.toLowerCase().includes('complexity')) return 'complexity';
    if (smell.toLowerCase().includes('duplicate')) return 'duplication';
    if (smell.toLowerCase().includes('style')) return 'style';
    return 'code_smells';
  } else if (typeof smell === 'object') {
    if (smell.category) return smell.category.toLowerCase();
    
    const description = smell.description || smell.message || '';
    if (description.toLowerCase().includes('security')) return 'security';
    if (description.toLowerCase().includes('sql injection')) return 'sql_injection';
    if (description.toLowerCase().includes('complexity')) return 'complexity';
    if (description.toLowerCase().includes('duplicate')) return 'duplication';
    if (description.toLowerCase().includes('style')) return 'style';
  }
  return 'code_smells'; 
}

export async function getQualityIssuesSummary(): Promise<any> {
  try {
    const graphData = await fetchGraphData();
    
    const issuesByCategory: Record<string, any[]> = {};
    const filesWithIssues: Record<string, {file_path: string, issue_count: number, [key: string]: any}> = {};
    
    graphData.nodes.forEach(node => {
      if (node.code_smells && node.code_smells.length > 0) {
        node.code_smells.forEach((smell: any) => {
          const category = getIssueCategory(smell);
          if (!issuesByCategory[category]) {
            issuesByCategory[category] = [];
          }
          
          const issue = typeof smell === 'string' 
            ? { description: smell, file_path: node.file_path || node.id } 
            : { ...smell, file_path: smell.file_path || node.file_path || node.id };
            
          issuesByCategory[category].push(issue);
      
          const filePath = issue.file_path;
          if (filePath) {
            if (!filesWithIssues[filePath]) {
              filesWithIssues[filePath] = { 
                file_path: filePath, 
                issue_count: 0 
              };
            }
            
            filesWithIssues[filePath].issue_count++;
            
            if (!filesWithIssues[filePath][category]) {
              filesWithIssues[filePath][category] = 0;
            }
            filesWithIssues[filePath][category]++;
          }
        });
      }
    });
    
    const category_counts: Record<string, number> = {};
    Object.keys(issuesByCategory).forEach(category => {
      category_counts[category] = issuesByCategory[category].length;
    });
    
    const files_with_most_issues = Object.values(filesWithIssues)
      .sort((a, b) => b.issue_count - a.issue_count)
      .slice(0, 10);
    
    return {
      issues_by_category: issuesByCategory,
      category_counts,
      files_with_most_issues,
      total_issues: Object.values(category_counts).reduce((sum, count) => sum + count, 0)
    };
  } catch (error) {
    console.error('Error getting quality issues summary:', error);
    throw error;
  }
}

export async function getComplexityBreakdown(): Promise<any> {
  try {
    const graphData = await fetchGraphData();
    
    const complexityFactors: Record<string, number> = {
      'if_statements': 0,
      'for_loops': 0,
      'while_loops': 0,
      'try_blocks': 0,
      'except_blocks': 0,
      'boolean_operations': 0,
      'and_operations': 0, 
      'or_operations': 0,
      'comprehensions': 0,
      'nested_functions': 0,
      'nested_classes': 0,
      'high_complexity': 0,
      'high_cognitive_complexity': 0,
      'high_nesting': 0
    };
    
    graphData.nodes.forEach(node => {
      if (node.metrics) {
        if (node.metrics.complexity && node.metrics.complexity > 10) {
          complexityFactors.high_complexity++;
        }
        
        if (node.metrics.cognitive_complexity && node.metrics.cognitive_complexity > 15) {
          complexityFactors.high_cognitive_complexity++;
        }
        
        if (node.metrics.nested_depth && node.metrics.nested_depth > 4) {
          complexityFactors.high_nesting++;
        }
        
        if (node.metrics.complexity) {
          const complexity = node.metrics.complexity;
          complexityFactors.if_statements += Math.floor(complexity * 0.4);
          complexityFactors.for_loops += Math.floor(complexity * 0.2);
          complexityFactors.while_loops += Math.floor(complexity * 0.1);
          complexityFactors.boolean_operations += Math.floor(complexity * 0.2);
          complexityFactors.try_blocks += Math.floor(complexity * 0.1);
        }
      }
      
      if (node.code_smells) {
        node.code_smells.forEach((smell: any) => {
          const description = typeof smell === 'string' ? smell : (smell.description || '');
          
          if (description.toLowerCase().includes('nested')) {
            if (description.toLowerCase().includes('function')) {
              complexityFactors.nested_functions++;
            } else if (description.toLowerCase().includes('class')) {
              complexityFactors.nested_classes++;
            } else {
              complexityFactors.high_nesting++;
            }
          }
          
          if (description.toLowerCase().includes('comprehension')) {
            complexityFactors.comprehensions++;
          }
        });
      }
    });
    
    return { total: complexityFactors };
  } catch (error) {
    console.error('Error getting complexity breakdown:', error);
    throw error;
  }
}

export async function getProjectMetrics(): Promise<any> {
  try {
    const graphData = await fetchGraphData();
    
    const files = new Set<string>();
    let totalFunctions = 0;
    let totalClasses = 0;
    let totalLines = 0;
    let sumComplexity = 0;
    let complexFunctionsCount = 0;
    let maxComplexity = 0;
    
    const fileMetrics: Record<string, any> = {};
    
    graphData.nodes.forEach(node => {
    if (node.file_path && node.file_path !== 'unknown'){
      if (node.file_path) {
        files.add(node.file_path);
        
        if (!fileMetrics[node.file_path]) {
          fileMetrics[node.file_path] = {
            path: node.file_path,
            lines: 0,
            functions: [],
            classes: [],
            issues_by_category: {}
          };
        }
      }
      
      if (node.metrics) {
        if (node.metrics.lines) {
          totalLines += node.metrics.lines;
          
          if (node.file_path) {
            fileMetrics[node.file_path].lines = Math.max(
              fileMetrics[node.file_path].lines,
              node.metrics.lines
            );
          }
        }
        
        if (node.metrics.functions) {
          totalFunctions += node.metrics.functions;
        }
        
        if (node.metrics.classes) {
          totalClasses += node.metrics.classes;
        }
        
        if (node.metrics.complexity) {
          sumComplexity += node.metrics.complexity;
          maxComplexity = Math.max(maxComplexity, node.metrics.complexity);
          
          if (node.metrics.complexity > 10) {
            complexFunctionsCount++;
          }
        }
      }
      
      if (node.type === 'function' && node.file_path) {
        fileMetrics[node.file_path].functions.push({
          name: node.name,
          complexity: node.metrics?.complexity || 0,
          cognitive_complexity: node.metrics?.cognitive_complexity || 0,
          nested_depth: node.metrics?.nested_depth || 0,
          lines: node.metrics?.lines || 0,
          params: node.metrics?.params || 0,
          code_smells: node.code_smells || [],
          line: 0 
        });
      } else if (node.type === 'class' && node.file_path) {
        fileMetrics[node.file_path].classes.push({
          name: node.name,
          complexity: node.metrics?.complexity || 0,
          methods: node.methods || {},
          lines: node.metrics?.lines || 0,
          code_smells: node.code_smells || [],
          line: 0
        });
      }
      
      if (node.code_smells && node.code_smells.length > 0 && node.file_path && typeof node.file_path === 'string') {
        const filePath = node.file_path;
        node.code_smells.forEach((smell: any) => {
          const category = getIssueCategory(smell);
          
          if (!fileMetrics[filePath].issues_by_category[category]) {
            fileMetrics[filePath].issues_by_category[category] = [];
          }
          
          const issue = typeof smell === 'string' 
            ? { description: smell } 
            : smell;
            
          fileMetrics[filePath].issues_by_category[category].push(issue);
        });
      }
    }
    });
    
    const totalFunctionNodes = graphData.nodes.filter(n => n.type === 'function').length;
    const totalClassNodes = graphData.nodes.filter(n => n.type === 'class').length;
    const totalModuleNodes = graphData.nodes.filter(n => n.type === 'module').length;
    
    const nodeCount = graphData.nodes.length;
    const avgComplexity = sumComplexity / 
      (graphData.nodes.filter(n => n.metrics?.complexity !== undefined).length || 1);
    
    return {
      files: fileMetrics,
      project_metrics: {
        total_files: files.size || totalModuleNodes,
        total_functions: totalFunctions || totalFunctionNodes,
        total_classes: totalClasses || totalClassNodes,
        total_lines: totalLines,
        avg_complexity: avgComplexity.toFixed(2),
        complex_functions_count: complexFunctionsCount,
        max_complexity: maxComplexity
      },
      dependency_metrics: {
        entry_points: graphData.nodes.filter(n => n.is_entry).length,
        nodes: nodeCount,
        links: graphData.links.length,
        avg_dependencies: (graphData.links.length / nodeCount).toFixed(2)
      }
    };
  } catch (error) {
    console.error('Error getting project metrics:', error);
    throw error;
  }
}
========================================
File: ./src/components/CodeMetricsGraphs.tsx
========================================
import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';

interface CodeMetricsGraphsProps {
  metrics: any;
  codeSmells: any[];
  className?: string;
}

const CodeMetricsGraphs: React.FC<CodeMetricsGraphsProps> = ({ 
  metrics, 
  codeSmells,
  className = '' 
}) => {
  const donutChartRef = useRef<SVGSVGElement>(null);
  const barChartRef = useRef<SVGSVGElement>(null);
  const radarChartRef = useRef<SVGSVGElement>(null);
  
  useEffect(() => {
    if (metrics && codeSmells) {
      renderDonutChart();
      renderBarChart();
      renderRadarChart();
    }
  }, [metrics, codeSmells]);
  
  const renderDonutChart = () => {
    if (!donutChartRef.current) return;
    
    d3.select(donutChartRef.current).selectAll('*').remove();
    
    const width = 300;
    const height = 300;
    const margin = 40;
    
    const radius = Math.min(width, height) / 2 - margin;
    
    const svg = d3.select(donutChartRef.current)
      .attr('width', width)
      .attr('height', height)
      .append('g')
      .attr('transform', `translate(${width / 2}, ${height / 2})`);
    
    const issueCategories: { [key: string]: number } = {};
    
    codeSmells.forEach(smell => {
      let category = 'Other';
      
      if (typeof smell === 'string') {
        const match = smell.match(/^\[([^\]]+)\]/);
        if (match) category = match[1];
      } else if (smell.category) {
        category = smell.category;
      } else if (smell.message && smell.message.includes('complexity')) {
        category = 'Complexity';
      } else if (smell.message && smell.message.includes('security')) {
        category = 'Security';
      }
      
      issueCategories[category] = (issueCategories[category] || 0) + 1;
    });
    
    const data = Object.entries(issueCategories).map(([name, value]) => ({name, value}));
    
    const color = d3.scaleOrdinal()
      .domain(data.map(d => d.name))
      .range([
        '#ef4444', // red (security)
        '#f59e0b', // amber (complexity)
        '#3b82f6', // blue (style)
        '#10b981', // emerald (duplication)
        '#8b5cf6', // violet (other)
        '#ec4899', // pink
        '#6366f1'  // indigo
      ]);
    
    const pie = d3.pie<any>()
      .sort(null)
      .value(d => d.value);
    
    const arc = d3.arc()
      .innerRadius(radius * 0.5)
      .outerRadius(radius * 0.8);
    
    const outerArc = d3.arc()
      .innerRadius(radius * 0.9)
      .outerRadius(radius * 0.9);
    
    const arcs = svg.selectAll('allSlices')
      .data(pie(data))
      .enter()
      .append('path')
      .attr('d', arc as any)
      .attr('fill', d => color(d.data.name) as string)
      .attr('stroke', 'white')
      .style('stroke-width', '2px')
      .style('opacity', 0.7);
    
    arcs.append('title')
        .text(d => `${d.data.name}: ${d.data.value} issues (${Math.round(d.data.value/codeSmells.length*100)}%)`);

    
    svg.selectAll('allPolylines')
      .data(pie(data))
      .enter()
      .append('polyline')
      .attr('stroke', 'black')
      .style('fill', 'none')
      .attr('stroke-width', 1)
      .attr('points', function(d) {
        const posA = arc.centroid(d as any);
        const posB = outerArc.centroid(d as any);
        const posC = outerArc.centroid(d as any);
        posC[0] = radius * 0.95 * (d.startAngle + (d.endAngle - d.startAngle) / 2 < Math.PI ? 1 : -1);
        return `${posA[0]},${posA[1]} ${posB[0]},${posB[1]} ${posC[0]},${posC[1]}`;
      });
    
    svg.selectAll('allLabels')
      .data(pie(data))
      .enter()
      .append('text')
      .text(d => `${d.data.name} (${d.data.value})`)
      .attr('transform', function(d) {
        const pos = outerArc.centroid(d as any);
        pos[0] = radius * 0.99 * (d.startAngle + (d.endAngle - d.startAngle) / 2 < Math.PI ? 1 : -1);
        return `translate(${pos})`;
      })
      .style('text-anchor', d => (d.startAngle + (d.endAngle - d.startAngle) / 2 < Math.PI ? 'start' : 'end'))
      .style('font-size', '12px');
    
    svg.append('text')
      .attr('text-anchor', 'middle')
      .attr('dy', '0.35em')
      .attr('font-size', '16px')
      .attr('font-weight', 'bold')
      .text(`${codeSmells.length} Issues`);
  };
  
  const renderBarChart = () => {
    if (!barChartRef.current || !metrics) return;
    
    d3.select(barChartRef.current).selectAll('*').remove();
    
    const width = 450;
    const height = 300;
    const margin = { top: 30, right: 30, bottom: 70, left: 60 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;
    
    const svg = d3.select(barChartRef.current)
      .attr('width', width)
      .attr('height', height)
      .append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);
    
    const metricsToShow = [
      { key: 'complexity', label: 'Complexity', threshold: 10 },
      { key: 'cognitive_complexity', label: 'Cognitive', threshold: 15 },
      { key: 'nested_depth', label: 'Nesting', threshold: 4 },
      { key: 'params', label: 'Parameters', threshold: 5 },
      { key: 'lines', label: 'Lines', threshold: 100, scale: 0.1 }
    ];
    
    const data = metricsToShow
      .filter(m => metrics[m.key] !== undefined)
      .map(m => ({
        name: m.label,
        value: m.scale ? metrics[m.key] * m.scale : metrics[m.key],
        originalValue: metrics[m.key],
        threshold: m.scale ? m.threshold * m.scale : m.threshold
      }));
    
    const x = d3.scaleBand()
      .domain(data.map(d => d.name))
      .range([0, innerWidth])
      .padding(0.3);
    
    const y = d3.scaleLinear()
      .domain([0, d3.max(data, d => Math.max(d.value, d.threshold)) as number * 1.1])
      .range([innerHeight, 0]);
    
    svg.append('g')
      .attr('transform', `translate(0,${innerHeight})`)
      .call(d3.axisBottom(x))
      .selectAll('text')
      .style('text-anchor', 'end')
      .attr('dx', '-.8em')
      .attr('dy', '.15em')
      .attr('transform', 'rotate(-45)');
    
    svg.append('g')
      .call(d3.axisLeft(y));
    
    svg.selectAll('threshold-lines')
      .data(data)
      .enter()
      .append('line')
      .attr('x1', d => (x(d.name) || 0))
      .attr('x2', d => (x(d.name) || 0) + x.bandwidth())
      .attr('y1', d => y(d.threshold))
      .attr('y2', d => y(d.threshold))
      .attr('stroke', '#ef4444')
      .attr('stroke-dasharray', '5,5')
      .attr('stroke-width', 1);
    
    svg.selectAll('bars')
      .data(data)
      .enter()
      .append('rect')
      .attr('x', d => x(d.name) || 0)
      .attr('y', d => y(d.value))
      .attr('width', x.bandwidth())
      .attr('height', d => innerHeight - y(d.value))
      .attr('fill', d => d.value > d.threshold ? '#ef4444' : '#3b82f6')
      .on('mouseover', function(_, d) {
        d3.select(this).attr('fill-opacity', 0.7);
        
        svg.append('text')
          .attr('class', 'tooltip-text')
          .attr('x', (x(d.name) || 0) + x.bandwidth() / 2)
          .attr('y', y(d.value) - 15)
          .attr('text-anchor', 'middle')
          .style('font-size', '12px')
          .style('font-weight', 'bold')
          .text(`${d.name}: ${d.originalValue}${d.value > d.threshold ? ' ⚠️' : ''}`);
      })
      .on('mouseout', function() {
        d3.select(this).attr('fill-opacity', 1);
        svg.selectAll('.tooltip-text').remove();
      });
      
    svg.selectAll('bar-values')
      .data(data)
      .enter()
      .append('text')
      .attr('x', d => (x(d.name) || 0) + x.bandwidth() / 2)
      .attr('y', d => y(d.value) - 5)
      .attr('text-anchor', 'middle')
      .text(d => d.originalValue)
      .style('font-size', '12px');
    
    svg.append('text')
      .attr('x', innerWidth / 2)
      .attr('y', -10)
      .attr('text-anchor', 'middle')
      .style('font-size', '16px')
      .style('font-weight', 'bold')
      .text('Key Metrics vs. Thresholds');
  };
  
  const renderRadarChart = () => {
    if (!radarChartRef.current || !metrics) return;
    
    d3.select(radarChartRef.current).selectAll('*').remove();
    
    const width = 350;
    const height = 350;
    const margin = 60;
    
    const svg = d3.select(radarChartRef.current)
      .attr('width', width)
      .attr('height', height)
      .append('g')
      .attr('transform', `translate(${width/2},${height/2})`);
    
    const radius = Math.min(width, height) / 2 - margin;
    
    const metricsToShow = [
      { key: 'complexity', label: 'Complexity', max: 20 },
      { key: 'cognitive_complexity', label: 'Cognitive Complexity', max: 25 },
      { key: 'nested_depth', label: 'Nesting Depth', max: 8 },
      { key: 'params', label: 'Parameters', max: 10 },
      { key: 'functions', label: 'Functions', max: 20 }
    ].filter(m => metrics[m.key] !== undefined);
    
    const data = [
      metricsToShow.map(m => ({
        axis: m.label,
        value: Math.min(1, metrics[m.key] / m.max)
      }))
    ];
    
    const allAxis = data[0].map(i => i.axis);
    const total = allAxis.length;
    const angleSlice = Math.PI * 2 / total;
    
    const rScale = d3.scaleLinear()
      .range([0, radius])
      .domain([0, 1]);
    
    const axisGrid = svg.append('g').attr('class', 'axis-grid');
    
    axisGrid.selectAll('.axis-line')
      .data(d3.range(1, 6))
      .enter()
      .append('circle')
      .attr('cx', 0)
      .attr('cy', 0)
      .attr('r', d => radius / 5 * d)
      .style('fill', 'none')
      .style('stroke', 'gray')
      .style('stroke-dasharray', '4,4')
      .style('opacity', 0.5);
    
    const axis = axisGrid.selectAll('.axis')
      .data(allAxis)
      .enter()
      .append('g')
      .attr('class', 'axis');
    
    axis.append('line')
      .attr('x1', 0)
      .attr('y1', 0)
      .attr('x2', (_, i) => rScale(1.1) * Math.cos(angleSlice * i - Math.PI / 2))
      .attr('y2', (_, i) => rScale(1.1) * Math.sin(angleSlice * i - Math.PI / 2))
      .style('stroke', 'gray')
      .style('stroke-width', '1px');
    
    axis.append('text')
      .attr('class', 'legend')
      .attr('text-anchor', 'middle')
      .attr('dy', '0.35em')
      .attr('x', (_, i) => rScale(1.15) * Math.cos(angleSlice * i - Math.PI / 2))
      .attr('y', (_, i) => rScale(1.15) * Math.sin(angleSlice * i - Math.PI / 2))
      .text(d => d)
      .style('font-size', '10px');
    
    const radarLine = d3.lineRadial<{axis: string, value: number}>()
      .curve(d3.curveLinearClosed)
      .radius(d => rScale(d.value))
      .angle((_, i) => i * angleSlice);
    
    const blobWrapper = svg.selectAll('.radar-wrapper')
      .data(data)
      .enter()
      .append('g')
      .attr('class', 'radar-wrapper');
    
    blobWrapper
      .append('path')
      .attr('class', 'radar-area')
      .attr('d', d => radarLine(d) as string)
      .style('fill', '#3b82f6')
      .style('fill-opacity', 0.5)
      .style('stroke', '#3b82f6')
      .style('stroke-width', '1px');
    
    blobWrapper.selectAll('.radar-circle')
      .data(d => d)
      .enter()
      .append('circle')
      .attr('class', 'radar-circle')
      .attr('r', 5)
      .attr('cx', (d, i) => rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2))
      .attr('cy', (d, i) => rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2))
      .style('fill', '#3b82f6')
      .style('stroke', 'none');
    
    svg.append('text')
      .attr('x', 0)
      .attr('y', -radius - 20)
      .attr('text-anchor', 'middle')
      .style('font-size', '16px')
      .style('font-weight', 'bold')
      .text('Complexity Radar');
  };
  
  return (
    <div className={`code-metrics-graphs ${className}`}>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
        <div className="bg-white p-4 rounded-lg shadow">
          <h3 className="text-lg font-semibold mb-4 text-center">Code Issues by Category</h3>
          <div className="flex justify-center">
            <svg ref={donutChartRef}></svg>
          </div>
        </div>
        
        <div className="bg-white p-4 rounded-lg shadow">
          <h3 className="text-lg font-semibold mb-4 text-center">Complexity Profile</h3>
          <div className="flex justify-center">
            <svg ref={radarChartRef}></svg>
          </div>
        </div>
      </div>
      
      <div className="bg-white p-4 rounded-lg shadow mb-8">
        <h3 className="text-lg font-semibold mb-4 text-center">Metrics vs Thresholds</h3>
        <div className="flex justify-center">
          <svg ref={barChartRef}></svg>
        </div>
      </div>
    </div>
  );
};

export default CodeMetricsGraphs;
========================================
File: ./src/styles.css
========================================
/* body {
    margin: 0;
    font-family: 'Segoe UI', Arial, sans-serif;
    background: #f8f9fa;
  }
  
  .node {
    cursor: pointer;
  }
  
  .node circle {
    fill: #fff;
  }
  
  .node:hover circle {
    filter: brightness(0.95);
  }
  
  .node text {
    font: 12px 'Segoe UI', sans-serif;
    font-weight: 500;
    text-anchor: start;
  }
  
  .link {
    stroke-width: 1.5px;
    fill: none;
    stroke-dasharray: none;
    opacity: 0.7;
  }
  
  .link-imports {
    stroke: #7c3aed;
  }
  
  .link-contains {
    stroke: #059669;
  }
  
  .link-calls {
    stroke: #ea580c;
  }
  
  .tooltip {
    position: absolute;
    padding: 12px;
    background: white;
    border: none;
    border-radius: 8px;
    pointer-events: none;
    font-size: 14px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    max-width: 300px;
  }
  
  .controls {
    position: fixed;
    top: 20px;
    left: 20px;
    background: white;
    padding: 16px;
    border-radius: 12px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    align-items: center;
  }
  
  .controls input {
    width: 250px;
    padding: 8px 12px;
    margin-bottom: 12px;
    border: 1px solid #e5e7eb;
    border-radius: 6px;
    font-size: 14px;
  }
  
  button {
    background: #1d4ed8;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    margin-right: 8px;
    transition: background 0.3s;
  }
  
  button:hover {
    background: #1e40af;
  }
  
  .legend {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: white;
    padding: 16px;
    border-radius: 12px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  }
  
  .legend-item {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    font-size: 14px;
  }
  
  .legend-color {
    width: 16px;
    height: 16px;
    border-radius: 4px;
    margin-right: 8px;
  }
  
  .node-module circle { stroke: #0284c7; }
  .node-class circle { stroke: #0891b2; }
  .node-function circle { stroke: #0d9488; }
  
  h2 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #111827;
    padding-bottom: 10px;
    border-bottom: 1px solid #e5e7eb;
  }
  
  h3 {
    margin-top: 20px;
    margin-bottom: 10px;
    color: #1f2937;
    font-size: 1.2em;
  }
  
  h4 {
    margin-top: 15px;
    margin-bottom: 10px;
    color: #374151;
  }
  
  .issue-category {
    margin-bottom: 15px;
    padding: 10px;
    border-radius: 6px;
    background: #f9fafb;
  }
  
  .quality-issues {
    margin-top: 20px;
    margin-bottom: 20px;
  }
  
  .quality-issues h3 {
    display: flex;
    align-items: center;
    color: #b91c1c;
  }
  
  .quality-issues h3::before {
    content: "⚠️";
    margin-right: 8px;
  }
  
  .security-issues {
    background: #fee2e2;
    border-left: 4px solid #ef4444;
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 0 6px 6px 0;
  }
  
  .complexity-issues {
    background: #fff7ed;
    border-left: 4px solid #f97316;
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 0 6px 6px 0;
  }
  
  .code-smell-issues {
    background: #f0fdf4;
    border-left: 4px solid #10b981;
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 0 6px 6px 0;
  }
  
  .duplication-issues {
    background: #eff6ff;
    border-left: 4px solid #3b82f6;
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 0 6px 6px 0;
  }
  
  .style-issues {
    background: #f0f9ff;
    border-left: 4px solid #0284c7;
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 0 6px 6px 0;
  }
  
  .issue-title {
    font-weight: 600;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
  }
  
  .security-issues .issue-title {
    color: #b91c1c;
  }
  
  .security-issues .issue-title::before {
    content: "🔒";
    margin-right: 8px;
  }
  
  .complexity-issues .issue-title {
    color: #c2410c;
  }
  
  .complexity-issues .issue-title::before {
    content: "🔄";
    margin-right: 8px;
  }
  
  .code-smell-issues .issue-title {
    color: #047857;
  }
  
  .code-smell-issues .issue-title::before {
    content: "👃";
    margin-right: 8px;
  }
  
  .duplication-issues .issue-title {
    color: #1d4ed8;
  }
  
  .duplication-issues .issue-title::before {
    content: "🔄";
    margin-right: 8px;
  }
  
  .style-issues .issue-title {
    color: #0369a1;
  }
  
  .style-issues .issue-title::before {
    content: "🎨";
    margin-right: 8px;
  }
  
  .issue-list {
    list-style: none;
    padding-left: 10px;
    margin: 0;
  }
  
  .issue-list li {
    padding: 6px 0;
    border-bottom: 1px solid rgba(0,0,0,0.1);
    display: flex;
    align-items: flex-start;
  }
  
  .issue-list li:last-child {
    border-bottom: none;
  }
  
  .issue-list li::before {
    content: "•";
    margin-right: 8px;
    color: #6b7280;
  }
  
  .issue-line {
    color: #6b7280;
    font-size: 0.85em;
    margin-left: auto;
    padding-left: 10px;
  }
  
  .metrics-section {
    margin-top: 20px;
    margin-bottom: 20px;
  }
  
  .metrics-table {
    width: 100%;
    border-collapse: collapse;
  }
  
  .metrics-table tr:nth-child(even) {
    background-color: #f9fafb;
  }
  
  .metrics-table td {
    padding: 10px;
    border-bottom: 1px solid #e5e7eb;
  }
  
  .metrics-table td:first-child {
    font-weight: 500;
  }
  
  .metrics-table .metric-warning {
    background-color: #fff7ed;
    color: #c2410c;
  }
  
  .connections-section {
    margin-top: 25px;
  }
  
  .node-type-pill {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 0.9em;
    font-weight: 500;
    margin-right: 10px;
  }
  
  .module {
    background: #dbeafe;
    color: #1e40af;
  }
  
  .class {
    background: #e0f2fe;
    color: #0369a1;
  }
  
  .function {
    background: #d1fae5;
    color: #047857;
  }
  
  .entry-point {
    background: #fef3c7;
    color: #92400e;
  }
  
  .connection-list {
    list-style: none;
    padding-left: 0;
  }
  
  .connection-list li {
    padding: 6px 0;
  }
  
  .link-type {
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.85em;
    margin-right: 8px;
  }
  
  .link-type.imports {
    background: #ede9fe;
    color: #7c3aed;
  }
  
  .link-type.contains {
    background: #d1fae5;
    color: #059669;
  }
  
  .link-type.calls {
    background: #ffedd5;
    color: #ea580c;
  } */
========================================
File: ./src/components/NodeMetrics.tsx
========================================
import React from 'react';

interface NodeMetricsProps {
  metrics: {
    complexity?: number;
    cognitive_complexity?: number;
    lines?: number;
    functions?: number;
    classes?: number;
    params?: number;
    methods?: number;
    nested_depth?: number;
    [key: string]: any;
  };
}

const NodeMetrics: React.FC<NodeMetricsProps> = ({ metrics }) => {
  const isWarning = (key: string, value: any): boolean => {
    if (typeof value !== 'number') return false;
    
    switch (key) {
      case 'complexity':
        return value > 10;
      case 'cognitive_complexity':
        return value > 15;
      case 'lines':
        return value > 100;
      case 'params':
        return value > 5;
      case 'methods':
        return value > 20;
      case 'nested_depth':
        return value > 4;
      default:
        return false;
    }
  };
  
  const formatKey = (key: string): string => {
    return key
      .replace(/_/g, ' ')
      .replace(/\b\w/g, c => c.toUpperCase());
  };
  
  return (
    <div className="metrics-section">
      <h3>📊 Detailed Metrics</h3>
      <table className="metrics-table">
        <tbody>
          {Object.entries(metrics).map(([key, value]) => {
            if (key.startsWith('_')) return null;
            
            const formattedKey = formatKey(key);
            const warning = isWarning(key, value);
            
            return (
              <tr key={key} className={warning ? 'metric-warning' : ''}>
                <td>{formattedKey}</td>
                <td>{value}</td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  );
};

export default NodeMetrics;
========================================
File: ./src/components/Graph.tsx
========================================
import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';

interface GraphProps {
  data: { nodes: any[]; links: any[] };
  onNodeClick: (node: any) => void;
}

const Graph: React.FC<GraphProps> = ({ data, onNodeClick }) => {
  const svgRef = useRef<SVGSVGElement>(null);

  useEffect(() => {
    if (!svgRef.current || !data.nodes.length) return;

    const svg = d3.select(svgRef.current).attr('width', 800).attr('height', 600);
    svg.selectAll('*').remove();

    const simulation = d3.forceSimulation(data.nodes)
      .force('link', d3.forceLink(data.links).id((d: any) => d.id))
      .force('charge', d3.forceManyBody().strength(-400))
      .force('center', d3.forceCenter(400, 300));

    const links = svg.append('g').selectAll('line')
      .data(data.links)
      .enter().append('line')
      .attr('stroke', '#999');

    const nodes = svg.append('g').selectAll('circle')
      .data(data.nodes)
      .enter().append('circle')
      .attr('r', 5)
      .attr('fill', 'blue')
      .on('click', (_event, d) => onNodeClick(d));

    simulation.on('tick', () => {
      links.attr('x1', (d: any) => d.source.x).attr('y1', (d: any) => d.source.y)
           .attr('x2', (d: any) => d.target.x).attr('y2', (d: any) => d.target.y);
      nodes.attr('cx', (d: any) => d.x).attr('cy', (d: any) => d.y);
    });
  }, [data, onNodeClick]);

  return <svg ref={svgRef} />;
};

export default Graph;
========================================
File: ./public/vite.svg
========================================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
========================================
File: ./eslint.config.js
========================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

========================================
File: ./index.html
========================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

========================================
File: ./tailwind.config.js
========================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
};
========================================
File: ./src/index.css
========================================
@tailwind base;
@tailwind components;
@tailwind utilities;
