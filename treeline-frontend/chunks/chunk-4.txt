================================================================================
CHUNK 5 OF 5
================================================================================

========================================
File: ./src/styles.css
========================================
/* body {
    margin: 0;
    font-family: 'Segoe UI', Arial, sans-serif;
    background: #f8f9fa;
  }
  
  .node {
    cursor: pointer;
  }
  
  .node circle {
    fill: #fff;
  }
  
  .node:hover circle {
    filter: brightness(0.95);
  }
  
  .node text {
    font: 12px 'Segoe UI', sans-serif;
    font-weight: 500;
    text-anchor: start;
  }
  
  .link {
    stroke-width: 1.5px;
    fill: none;
    stroke-dasharray: none;
    opacity: 0.7;
  }
  
  .link-imports {
    stroke: #7c3aed;
  }
  
  .link-contains {
    stroke: #059669;
  }
  
  .link-calls {
    stroke: #ea580c;
  }
  
  .tooltip {
    position: absolute;
    padding: 12px;
    background: white;
    border: none;
    border-radius: 8px;
    pointer-events: none;
    font-size: 14px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    max-width: 300px;
  }
  
  .controls {
    position: fixed;
    top: 20px;
    left: 20px;
    background: white;
    padding: 16px;
    border-radius: 12px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    align-items: center;
  }
  
  .controls input {
    width: 250px;
    padding: 8px 12px;
    margin-bottom: 12px;
    border: 1px solid #e5e7eb;
    border-radius: 6px;
    font-size: 14px;
  }
  
  button {
    background: #1d4ed8;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    margin-right: 8px;
    transition: background 0.3s;
  }
  
  button:hover {
    background: #1e40af;
  }
  
  .legend {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: white;
    padding: 16px;
    border-radius: 12px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  }
  
  .legend-item {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    font-size: 14px;
  }
  
  .legend-color {
    width: 16px;
    height: 16px;
    border-radius: 4px;
    margin-right: 8px;
  }
  
  .node-module circle { stroke: #0284c7; }
  .node-class circle { stroke: #0891b2; }
  .node-function circle { stroke: #0d9488; }
  
  h2 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #111827;
    padding-bottom: 10px;
    border-bottom: 1px solid #e5e7eb;
  }
  
  h3 {
    margin-top: 20px;
    margin-bottom: 10px;
    color: #1f2937;
    font-size: 1.2em;
  }
  
  h4 {
    margin-top: 15px;
    margin-bottom: 10px;
    color: #374151;
  }
  
  .issue-category {
    margin-bottom: 15px;
    padding: 10px;
    border-radius: 6px;
    background: #f9fafb;
  }
  
  .quality-issues {
    margin-top: 20px;
    margin-bottom: 20px;
  }
  
  .quality-issues h3 {
    display: flex;
    align-items: center;
    color: #b91c1c;
  }
  
  .quality-issues h3::before {
    content: "‚ö†Ô∏è";
    margin-right: 8px;
  }
  
  .security-issues {
    background: #fee2e2;
    border-left: 4px solid #ef4444;
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 0 6px 6px 0;
  }
  
  .complexity-issues {
    background: #fff7ed;
    border-left: 4px solid #f97316;
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 0 6px 6px 0;
  }
  
  .code-smell-issues {
    background: #f0fdf4;
    border-left: 4px solid #10b981;
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 0 6px 6px 0;
  }
  
  .duplication-issues {
    background: #eff6ff;
    border-left: 4px solid #3b82f6;
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 0 6px 6px 0;
  }
  
  .style-issues {
    background: #f0f9ff;
    border-left: 4px solid #0284c7;
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 0 6px 6px 0;
  }
  
  .issue-title {
    font-weight: 600;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
  }
  
  .security-issues .issue-title {
    color: #b91c1c;
  }
  
  .security-issues .issue-title::before {
    content: "üîí";
    margin-right: 8px;
  }
  
  .complexity-issues .issue-title {
    color: #c2410c;
  }
  
  .complexity-issues .issue-title::before {
    content: "üîÑ";
    margin-right: 8px;
  }
  
  .code-smell-issues .issue-title {
    color: #047857;
  }
  
  .code-smell-issues .issue-title::before {
    content: "üëÉ";
    margin-right: 8px;
  }
  
  .duplication-issues .issue-title {
    color: #1d4ed8;
  }
  
  .duplication-issues .issue-title::before {
    content: "üîÑ";
    margin-right: 8px;
  }
  
  .style-issues .issue-title {
    color: #0369a1;
  }
  
  .style-issues .issue-title::before {
    content: "üé®";
    margin-right: 8px;
  }
  
  .issue-list {
    list-style: none;
    padding-left: 10px;
    margin: 0;
  }
  
  .issue-list li {
    padding: 6px 0;
    border-bottom: 1px solid rgba(0,0,0,0.1);
    display: flex;
    align-items: flex-start;
  }
  
  .issue-list li:last-child {
    border-bottom: none;
  }
  
  .issue-list li::before {
    content: "‚Ä¢";
    margin-right: 8px;
    color: #6b7280;
  }
  
  .issue-line {
    color: #6b7280;
    font-size: 0.85em;
    margin-left: auto;
    padding-left: 10px;
  }
  
  .metrics-section {
    margin-top: 20px;
    margin-bottom: 20px;
  }
  
  .metrics-table {
    width: 100%;
    border-collapse: collapse;
  }
  
  .metrics-table tr:nth-child(even) {
    background-color: #f9fafb;
  }
  
  .metrics-table td {
    padding: 10px;
    border-bottom: 1px solid #e5e7eb;
  }
  
  .metrics-table td:first-child {
    font-weight: 500;
  }
  
  .metrics-table .metric-warning {
    background-color: #fff7ed;
    color: #c2410c;
  }
  
  .connections-section {
    margin-top: 25px;
  }
  
  .node-type-pill {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 0.9em;
    font-weight: 500;
    margin-right: 10px;
  }
  
  .module {
    background: #dbeafe;
    color: #1e40af;
  }
  
  .class {
    background: #e0f2fe;
    color: #0369a1;
  }
  
  .function {
    background: #d1fae5;
    color: #047857;
  }
  
  .entry-point {
    background: #fef3c7;
    color: #92400e;
  }
  
  .connection-list {
    list-style: none;
    padding-left: 0;
  }
  
  .connection-list li {
    padding: 6px 0;
  }
  
  .link-type {
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.85em;
    margin-right: 8px;
  }
  
  .link-type.imports {
    background: #ede9fe;
    color: #7c3aed;
  }
  
  .link-type.contains {
    background: #d1fae5;
    color: #059669;
  }
  
  .link-type.calls {
    background: #ffedd5;
    color: #ea580c;
  } */
========================================
File: ./src/components/ComplexityTimeline.tsx
========================================
import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';

interface ComplexityTimelineProps {
  currentComplexity: number;
  currentCognitiveComplexity: number;
  currentNestedDepth?: number;
  className?: string;
}

const ComplexityTimeline: React.FC<ComplexityTimelineProps> = ({ 
  currentComplexity, 
  currentCognitiveComplexity,
  currentNestedDepth,
  className = ''
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  
  useEffect(() => {
    if (!svgRef.current) return;
    
    d3.select(svgRef.current).selectAll('*').remove();
    
    const margin = { top: 30, right: 80, bottom: 50, left: 60 };
    const width = 600 - margin.left - margin.right;
    const height = 300 - margin.top - margin.bottom;
    
    // Create SVG
    const svg = d3.select(svgRef.current)
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom)
      .append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);
    
    const refactoringSteps = 5;
    const complexityData = [];
    const cognitiveData = [];
    const nestedDepthData = [];
    
    for (let i = 0; i <= refactoringSteps; i++) {
      const reductionFactor = 1 - (i * 0.15); 
      
      complexityData.push({
        step: i,
        value: Math.max(2, Math.round(currentComplexity * reductionFactor)),
        metric: 'complexity'
      });
      
      cognitiveData.push({
        step: i,
        value: Math.max(1, Math.round(currentCognitiveComplexity * reductionFactor)),
        metric: 'cognitive'
      });
      
      if (currentNestedDepth) {
        nestedDepthData.push({
          step: i,
          value: Math.max(1, Math.round(currentNestedDepth * reductionFactor)),
          metric: 'depth'
        });
      }
    }
    
    const allData = [...complexityData, ...cognitiveData];
    if (currentNestedDepth) allData.push(...nestedDepthData);
    
    const x = d3.scaleLinear()
      .domain([0, refactoringSteps])
      .range([0, width]);
      
    const y = d3.scaleLinear()
      .domain([0, d3.max(allData, d => d.value) || 0])
      .nice()
      .range([height, 0]);
    
    svg.append('g')
      .attr('transform', `translate(0,${height})`)
      .call(d3.axisBottom(x).ticks(refactoringSteps + 1).tickFormat(d => `Step ${d}`));
    
    svg.append('g')
      .call(d3.axisLeft(y));
    
    svg.append('text')
      .attr('x', width / 2)
      .attr('y', height + 40)
      .attr('text-anchor', 'middle')
      .style('font-size', '14px')
      .style('font-weight', '500')
      .text('Refactoring Steps');
    
    svg.append('text')
      .attr('transform', 'rotate(-90)')
      .attr('x', -height / 2)
      .attr('y', -40)
      .attr('text-anchor', 'middle')
      .style('font-size', '14px')
      .style('font-weight', '500')
      .text('Complexity Score');
    
    svg.append('line')
      .attr('x1', 0)
      .attr('x2', width)
      .attr('y1', y(10))
      .attr('y2', y(10))
      .attr('stroke', '#ef4444')
      .attr('stroke-dasharray', '5,5')
      .attr('stroke-width', 1);
    
    svg.append('text')
      .attr('x', width)
      .attr('y', y(10) - 5)
      .attr('text-anchor', 'end')
      .attr('fill', '#ef4444')
      .attr('font-size', '12px')
      .text('Complexity Threshold (10)');
    
    svg.append('line')
      .attr('x1', 0)
      .attr('x2', width)
      .attr('y1', y(15))
      .attr('y2', y(15))
      .attr('stroke', '#f59e0b')
      .attr('stroke-dasharray', '5,5')
      .attr('stroke-width', 1);
    
    svg.append('text')
      .attr('x', width)
      .attr('y', y(15) - 5)
      .attr('text-anchor', 'end')
      .attr('fill', '#f59e0b')
      .attr('font-size', '12px')
      .text('Cognitive Complexity Threshold (15)');
    
    const complexityLine = d3.line<{step: number, value: number}>()
      .x(d => x(d.step))
      .y(d => y(d.value))
      .curve(d3.curveMonotoneX);
    
    const cognitiveComplexityLine = d3.line<{step: number, value: number}>()
      .x(d => x(d.step))
      .y(d => y(d.value))
      .curve(d3.curveMonotoneX);
    
    const nestedDepthLine = d3.line<{step: number, value: number}>()
      .x(d => x(d.step))
      .y(d => y(d.value))
      .curve(d3.curveMonotoneX);
    
    svg.append('path')
      .datum(complexityData)
      .attr('fill', 'none')
      .attr('stroke', '#3b82f6')
      .attr('stroke-width', 2)
      .attr('d', complexityLine);
    
    svg.append('path')
      .datum(cognitiveData)
      .attr('fill', 'none')
      .attr('stroke', '#f59e0b')
      .attr('stroke-width', 2)
      .attr('d', cognitiveComplexityLine);
    
    if (currentNestedDepth) {
      svg.append('path')
        .datum(nestedDepthData)
        .attr('fill', 'none')
        .attr('stroke', '#10b981')
        .attr('stroke-width', 2)
        .attr('d', nestedDepthLine);
    }
    
    svg.selectAll('.complexity-dot')
      .data(complexityData)
      .enter()
      .append('circle')
      .attr('class', 'complexity-dot')
      .attr('cx', d => x(d.step))
      .attr('cy', d => y(d.value))
      .attr('r', 5)
      .attr('fill', '#3b82f6');
    
    svg.selectAll('.cognitive-dot')
      .data(cognitiveData)
      .enter()
      .append('circle')
      .attr('class', 'cognitive-dot')
      .attr('cx', d => x(d.step))
      .attr('cy', d => y(d.value))
      .attr('r', 5)
      .attr('fill', '#f59e0b');
    
    if (currentNestedDepth) {
      svg.selectAll('.depth-dot')
        .data(nestedDepthData)
        .enter()
        .append('circle')
        .attr('class', 'depth-dot')
        .attr('cx', d => x(d.step))
        .attr('cy', d => y(d.value))
        .attr('r', 5)
        .attr('fill', '#10b981');
    }
    
    svg.selectAll('.complexity-label')
      .data(complexityData)
      .enter()
      .append('text')
      .attr('class', 'complexity-label')
      .attr('x', d => x(d.step))
      .attr('y', d => y(d.value) - 10)
      .attr('text-anchor', 'middle')
      .style('font-size', '12px')
      .text(d => d.value);
    
    svg.selectAll('.cognitive-label')
      .data(cognitiveData)
      .enter()
      .append('text')
      .attr('class', 'cognitive-label')
      .attr('x', d => x(d.step))
      .attr('y', d => y(d.value) - 10)
      .attr('text-anchor', 'middle')
      .style('font-size', '12px')
      .text(d => d.value);
    
    if (currentNestedDepth) {
      svg.selectAll('.depth-label')
        .data(nestedDepthData)
        .enter()
        .append('text')
        .attr('class', 'depth-label')
        .attr('x', d => x(d.step))
        .attr('y', d => y(d.value) - 10)
        .attr('text-anchor', 'middle')
        .style('font-size', '12px')
        .text(d => d.value);
    }
    
    const legend = svg.append('g')
      .attr('transform', `translate(${width + 10}, 0)`);
    
    legend.append('rect')
      .attr('x', 0)
      .attr('y', 0)
      .attr('width', 15)
      .attr('height', 15)
      .attr('fill', '#3b82f6');
    
    legend.append('text')
      .attr('x', 20)
      .attr('y', 12)
      .text('Complexity')
      .style('font-size', '12px');
    
    legend.append('rect')
      .attr('x', 0)
      .attr('y', 25)
      .attr('width', 15)
      .attr('height', 15)
      .attr('fill', '#f59e0b');
    
    legend.append('text')
      .attr('x', 20)
      .attr('y', 37)
      .text('Cognitive')
      .style('font-size', '12px');
    
    if (currentNestedDepth) {
      legend.append('rect')
        .attr('x', 0)
        .attr('y', 50)
        .attr('width', 15)
        .attr('height', 15)
        .attr('fill', '#10b981');
      
      legend.append('text')
        .attr('x', 20)
        .attr('y', 62)
        .text('Nesting')
        .style('font-size', '12px');
    }
    
    svg.append('text')
      .attr('x', width / 2)
      .attr('y', -10)
      .attr('text-anchor', 'middle')
      .style('font-size', '16px')
      .style('font-weight', 'bold')
      .text('Estimated Complexity Reduction with Refactoring');
      
  }, [currentComplexity, currentCognitiveComplexity, currentNestedDepth]);
  
  return (
    <div className={`complexity-timeline ${className}`}>
      <svg ref={svgRef}></svg>
      <div className="mt-4 text-sm text-gray-600">
        <p>This chart illustrates the potential reduction in complexity metrics through incremental refactoring steps.</p>
        <p>Each step assumes approximately 15% complexity reduction from the previous state.</p>
      </div>
    </div>
  );
};

export default ComplexityTimeline;
========================================
File: ./src/services/dataServices.ts
========================================
import { GraphData } from '../types';

const API_BASE_URL = 'http://localhost:8000';

export interface GraphDataParams {
  limit?: number;
  offset?: number;
  minConnections?: number;
  types?: string[];
  searchTerm?: string;
  includeEntryPointsOnly?: boolean;
}

export async function fetchGraphData(params: GraphDataParams = {}): Promise<GraphData> {
  try {
    const queryParams = new URLSearchParams();
    
    if (params.limit) queryParams.append('limit', params.limit.toString());
    if (params.offset) queryParams.append('offset', params.offset.toString());
    if (params.minConnections) queryParams.append('min_connections', params.minConnections.toString());
    if (params.types && params.types.length > 0) {
      params.types.forEach(type => queryParams.append('type', type));
    }
    if (params.searchTerm) queryParams.append('search', params.searchTerm);
    if (params.includeEntryPointsOnly) queryParams.append('entry_points_only', 'true');
    
    const queryString = queryParams.toString();
    const url = `${API_BASE_URL}/api/graph-data${queryString ? `?${queryString}` : ''}`;
    
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching graph data:', error);
    throw error;
  }
}

export async function fetchNodeData(nodeId: string): Promise<any> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/node/${nodeId}`);
    
    if (!response.ok) {
      if (response.status === 404) {
        const errorData = await response.json();
        throw new Error(`Node not found: ${errorData.detail || 'The requested node does not exist'}`);
      }
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error(`Error fetching data for node ${nodeId}:`, error);
    throw error;
  }
}

export async function fetchNodeConnections(nodeId: string, depth: number = 1): Promise<any> {
  try {
    const response = await fetch(
      `${API_BASE_URL}/api/node/${nodeId}/connections?depth=${depth}`
    );
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error(`Error fetching connections for node ${nodeId}:`, error);
    throw error;
  }
}

export async function fetchGraphSummary(): Promise<any> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/graph-summary`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching graph summary:', error);
    throw error;
  }
}

export async function searchNodes(query: string, limit: number = 20): Promise<any[]> {
  try {
    const response = await fetch(
      `${API_BASE_URL}/api/search?q=${encodeURIComponent(query)}&limit=${limit}`
    );
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error searching nodes:', error);
    throw error;
  }
}
========================================
File: ./src/types.ts
========================================
export interface CodeNode {
    id: string;
    name: string;
    type: 'module' | 'class' | 'function';
    is_entry?: boolean;
    docstring?: string;
    code_smells?: Array<string | CodeSmell>;
    security_issues?: Array<string | CodeSmell>;
    complexity_issues?: Array<string | CodeSmell>;
    duplication_issues?: Array<string | CodeSmell>;
    radius?: number;
    metrics?: {
      complexity?: number;
      cognitive_complexity?: number;
      lines?: number;
      functions?: number;
      classes?: number;
      params?: number;
      methods?: number;
      nested_depth?: number;
      [key: string]: any;
    };
    methods?: {
      [key: string]: any;
    };
    x?: number;
    y?: number;
    vx?: number;
    vy?: number;
    fx?: number | null;
    fy?: number | null;
  }
  
  export interface CodeLink {
    source: string | CodeNode;
    target: string | CodeNode;
    type: 'imports' | 'contains' | 'calls';
  }
  
  export interface CodeSmell {
    category?: string;
    description?: string;
    message?: string;
    line?: number | null;
    lineno?: number | null;
  }
  
  export interface GraphData {
    nodes: CodeNode[];
    links: CodeLink[];
  }
  
  export interface Issue {
    category: string;
    description: string;
    line: number | null;
    source: string;
  }
========================================
File: ./src/components/Controls.tsx
========================================
import React, { useState } from 'react';

interface ControlsProps {
  onResetZoom: () => void;
  onToggleLayout: () => void;
  onSearchChange: (term: string) => void;
  isHierarchical: boolean;
  onToggleHierarchical: () => void;
}

const Controls: React.FC<ControlsProps> = ({ 
  onResetZoom, 
  onToggleLayout, 
  onSearchChange,
  isHierarchical,
  onToggleHierarchical
}) => {
  const [searchTerm, setSearchTerm] = useState('');
  
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newTerm = e.target.value;
    setSearchTerm(newTerm);
    onSearchChange(newTerm);
  };
  
  return (
    <div id="controls">
      <div>
        <input 
          type="text" 
          id="search" 
          placeholder="Search nodes..." 
          value={searchTerm}
          onChange={handleSearchChange}
        />
      </div>
      <div className="controls-buttons">
        <button onClick={onResetZoom}>Reset View</button>
        <button onClick={onToggleLayout}>Toggle Layout</button>
        <button onClick={onToggleHierarchical}>
          {isHierarchical ? 'Force Layout' : 'Hierarchical View'}
        </button>
      </div>
    </div>
  );
};

export default Controls;
========================================
File: ./eslint.config.js
========================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

========================================
File: ./index.html
========================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

========================================
File: ./tailwind.config.js
========================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
};
========================================
File: ./src/vite-env.d.ts
========================================
/// <reference types="vite/client" />

