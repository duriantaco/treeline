<!-- treeline/static/index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Code Structure Visualization</title>
    <script
    src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js">
    </script>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #f8f9fa;
        }
        .node {
            cursor: pointer;
        }
        .node circle {
            fill: #fff;
        }
        .node:hover circle {
            filter: brightness(0.95);
        }
        .node text {
            font: 12px 'Segoe UI', sans-serif;
            font-weight: 500;
            text-anchor: start;
        }
        .link {
            stroke-width: 1.5px;
            fill: none;
            stroke-dasharray: none;
            opacity: 0.7;
        }

        .link-added { stroke: #22c55e; stroke-width: 3px; }
        .link-removed { stroke: #ef4444; stroke-width: 3px; opacity: 0.7; }

        .link-imports {
            stroke: #7c3aed; /* purple */
        }
        .link-contains {
            stroke: #059669; /* green */
        }
        .link-calls {
            stroke: #ea580c; /* orange */
        }
        .tooltip {
            position: absolute;
            padding: 12px;
            background: white;
            border: none;
            border-radius: 8px;
            pointer-events: none;
            font-size: 14px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            max-width: 300px;
        }
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: white;
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }
        #search {
            width: 250px;
            padding: 8px 12px;
            margin-bottom: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 14px;
        }
        button {
            background: #1d4ed8;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 8px;
            transition: background 0.3s;
        }
        button:hover {
            background: #1e40af;
        }
        .legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            margin-right: 8px;
        }
        .node-module circle { stroke: #0284c7; }
        .node-class circle { stroke: #0891b2; }
        .node-function circle { stroke: #0d9488; }

        .node-added circle { fill: #22c55e; }    /* Green for added */
        .node-removed circle { fill: #ef4444; }  /* Red for removed */
    </style>
</head>
<body>
    <div id="controls">
        <input type="text" id="search" placeholder="Search nodes...">
        <button onclick="resetZoom()">Reset View</button>
        <button onclick="toggleLayout()">Toggle Layout</button>
    </div>
    <div class="legend">
        <h3 style="margin-top: 0; margin-bottom: 12px;">Legend</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #0284c7;"></div>
            <span>Module</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #fbbf24;"></div>
            <span>Entry Point</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0891b2;"></div>
            <span>Class</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0d9488;"></div>
            <span>Function</span>
        </div>
        <div style="margin-top: 16px; border-top: 1px solid #e5e7eb; padding-top: 12px;">
            <div class="legend-item">
                <div style="width: 40px; height: 2px;
                background: #7c3aed;
                margin-right: 8px;"></div>
                <span>Imports</span>
            </div>
            <div class="legend-item">
                <div style="width: 40px; height: 2px;
                background: #059669;
                margin-right: 8px;"></div>
                <span>Contains</span>
            </div>
            <div class="legend-item">
                <div style="width: 40px; height: 2px;
                background: #ea580c;
                margin-right: 8px;"></div>
                <span>Calls</span>
            </div>
        </div>
    </div>
    <svg id="visualization"></svg>
    <script>
        const data = GRAPH_DATA_PLACEHOLDER;

        let width = window.innerWidth;
        let height = window.innerHeight;
        let isRadial = false;
        let isHierarchical = false;

        function groupByModule() {
            const moduleGroups = {};
            data.nodes.forEach(node => {
                if (node.type === 'module') {
                    moduleGroups[node.id] = {
                        x: 0, y: 0,
                        children: []
                    };
                }
            });

            data.links.forEach(link => {
                if (link.type === 'contains') {
                    const module = moduleGroups[link.source.id];
                    if (module) {
                        module.children.push(link.target.id);
                    }
                }
            });

            return moduleGroups;
        }

        function resetZoom() {
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity
            );
        }

        function forceCluster() {
            const strength = 0.15;
            let nodes;

            function force(alpha) {
                const moduleGroups = groupByModule();

                nodes.forEach(node => {
                    const group = Object.values(moduleGroups)
                        .find(g => g.children.includes(node.id));

                    if (group) {
                        node.vx += (group.x - node.x) * strength * alpha;
                        node.vy += (group.y - node.y) * strength * alpha;
                    }
                });
            }

            force.initialize = function(_nodes) {
                nodes = _nodes;
            }

            return force;
        }

        function getNodeSize(node) {
            switch(node.type) {
                case 'module': return 12;
                case 'class': return 10;
                default: return 8;
            }
        }

        function linkArc(d) {
            return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
        }


        function ticked() {
            link.attr("d", linkArc);
            node.attr("transform", d => `translate(${d.x},${d.y})`);
        }


        function drag(simulation) {

            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }

        function toggleLayout() {
            isRadial = !isRadial;
            if (isRadial) {
                simulation
                    .force("x", null)
                    .force("y", null)
                    .force("r", d3.forceRadial(250, width / 2, height / 2))
                    .force("charge", d3.forceManyBody().strength(-100));
            } else {
                simulation
                    .force("r", null)
                    .force("x", d3.forceX(width / 2).strength(0.1))
                    .force("y", d3.forceY(height / 2).strength(0.1))
                    .force("charge", d3.forceManyBody().strength(-1000));
            }
            simulation.alpha(1).restart();
        }

        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink()
                .id(d => d.id)
                .distance(100)
                .strength(0.5))
            .force("charge", d3.forceManyBody()
                .strength(-400))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(30))
            .force("x", d3.forceX(width / 2).strength(0.1))
            .force("y", d3.forceY(height / 2).strength(0.1));

        function setHierarchicalLayout() {
            simulation.stop();

            // convert links to a parent->child structure
            const rootNodes = data.nodes.filter(
                n => n.type === 'module' &&
                !data.links.some(l => l.type === 'contains' && l.target.id === n.id)
            );

            // tree object
            function buildTree(node) {
                const children = data.links
                    .filter(l => l.type === 'contains' && l.source.id === node.id)
                    .map(l => data.nodes.find(n => n.id === l.target.id) || {});
                return {
                    ...node,
                    children: children.map(buildTree)
                };
            }

            let hierarchicalData = { name: 'root', children: rootNodes.map(buildTree) };

            // change the height for more vertical spacing here at the far right side of the tree
            const root = d3.hierarchy(hierarchicalData);
            const treeLayout = d3.tree().size([height * 3, width - 200]);
            treeLayout(root);

            root.descendants().forEach(d => {
                if (!d.data.id) return;
                let original = data.nodes.find(n => n.id === d.data.id);
                if (original) {
                    original.x = d.y;
                    original.y = d.x;
                }
            });

            node.transition()
                .duration(750)
                .attr("transform", d => `translate(${d.x},${d.y})`);

            link.transition()
                .duration(750)
                .attr("d", d => {
                    if (d.type === 'contains') {
                        return `M${d.source.x},${d.source.y}
                                C${d.source.x},${(d.source.y + d.target.y) / 2}
                                ${d.target.x},${(d.source.y + d.target.y) / 2}
                                ${d.target.x},${d.target.y}`;
                    }
                    return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
                });

            const bounds = {
                left: Math.min(...data.nodes.map(n => n.x)),
                right: Math.max(...data.nodes.map(n => n.x)),
                top: Math.min(...data.nodes.map(n => n.y)),
                bottom: Math.max(...data.nodes.map(n => n.y))
            };
            const centerX = width / 2 - (bounds.left + (bounds.right - bounds.left) / 2);
            const centerY = height / 2 - (bounds.top + (bounds.bottom - bounds.top) / 2);

            g.transition()
                .duration(750)
                .attr("transform", `translate(${centerX},${centerY})`);
        }

        const layoutButton = document.querySelector('#controls button:last-child');
        layoutButton.onclick = () => {
            isHierarchical = !isHierarchical;
            if (isHierarchical) {
                setHierarchicalLayout();
                layoutButton.textContent = 'Force Layout';
            } else {
                g.transition()
                    .duration(750)
                    .attr("transform", "");
                simulation.alpha(1).restart();
                layoutButton.textContent = 'Hierarchical View';
            }
        };

        document.querySelector('#controls').appendChild(layoutButton);

        const svg = d3.select("#visualization")
            .attr("width", width)
            .attr("height", height);

        svg.append("defs").selectAll("marker")
            .data(["imports", "contains", "calls"])
            .join("marker")
            .attr("id", d => `arrow-${d}`)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 15)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("fill", d => d === "imports" ? "#7c3aed" : d === "contains" ? "#059669" : "#ea580c")
            .attr("d", "M0,-5L10,0L0,5");

        const g = svg.append("g");

        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

        svg.call(zoom);



        const moduleGroups = g.append("g")
            .selectAll(".module-group")
            .data(Object.values(groupByModule()))
            .join("g")
            .attr("class", "module-group")
            .append("rect")
            .attr("fill", "#f3f4f6")
            .attr("rx", 10)
            .attr("ry", 10)
            .attr("opacity", 0.5);


        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        const legendContent = d3.select(".legend")
        .append("div")
        .style("margin-top", "16px")
        .style("border-top", "1px solid #e5e7eb")
        .style("padding-top", "12px");

        legendContent.append("div")
        .attr("class", "legend-item")
        .html(`
            <div class="legend-color" style="background: #ef4444;"></div>
            <span>Complex Node (Exceeds Complexity Threshold)</span>
        `);


        d3.select("#search").on("input", function() {
            const term = this.value.toLowerCase();
            if (term === "") {
                node.style("opacity", 1);
                link.style("opacity", 0.7);
                return;
            }

            const matchedNodes = new Set();
            node.each(function(d) {
                if (d.name.toLowerCase().includes(term)) {
                    matchedNodes.add(d.id);
                    data.links.forEach(l => {
                        if (l.source.id === d.id) matchedNodes.add(l.target.id);
                        if (l.target.id === d.id) matchedNodes.add(l.source.id);
                    });
                }
            });

            node.style("opacity", d => matchedNodes.has(d.id) ? 1 : 0.1);
            link.style("opacity", d =>
                matchedNodes.has(d.source.id) && matchedNodes.has(d.target.id) ? 0.7 : 0.1
            );
        });

        const link = g.append("g")
            .selectAll("path")
            .data(data.links)
            .join("path")
            .attr("class", d => `link link-${d.type}`)
            .attr("marker-end", d => `url(#arrow-${d.type})`);

        const node = g.append("g")
            .selectAll(".node")
            .data(data.nodes)
            .join("g")
            .attr("class", d => `node node-${d.type}`)
            .call(drag(simulation));

            node.append("rect")
                .attr("class", "text-background")
                .attr("fill", "white")
                .attr("fill-opacity", 0.9)
                .attr("rx", 3)
                .attr("ry", 3);

            node.append("circle")
                .attr("r", d => getNodeSize(d))
                .style("fill", d => {
                    if (d.is_entry) return "#fbbf24";
                    if (d.metrics && (
                        d.metrics.complexity > 10 ||
                        d.metrics.cognitive_complexity > 15 ||
                        (d.type === 'class' && d.metrics.complexity > 50)
                    )) return "#ef4444";
                    return "#fff";
                })
                .style("stroke", d => {
                    if (d.type === 'module') return "#0284c7";
                    if (d.type === 'class') return "#0891b2";
                    return "#0d9488";
                })
                .style("stroke-width", "2px");

            node.append("text")
                .attr("dy", ".35em")
                .attr("x", d => getNodeSize(d) + 8)
                .attr("class", "node-text")
                .text(d => d.name)
                .style("fill", "#333")
                .each(function(d) {
                    const bbox = this.getBBox();
                    d3.select(this.parentNode)
                        .select("rect.text-background")
                        .attr("x", bbox.x - 4)
                        .attr("y", bbox.y - 2)
                        .attr("width", bbox.width + 8)
                        .attr("height", bbox.height + 4);
                    });

        node.on("mouseover", function(event, d) {
            tooltip.transition()
                .duration(200)
                .style("opacity", .9);

        // generating tooltip content. providing info about object d
        let connections = data.links.filter(l =>
                l.source.id === d.id || l.target.id === d.id
            );

            let tooltipContent = `<strong>${d.name}</strong><br>`;
            if (d.type === 'class') {
                tooltipContent += `<br><strong>Methods:</strong><br>`;
                for (let [methodName, info] of Object.entries(d.methods || {})) {
                    tooltipContent += `• ${methodName}<br>`;
                    if (info.docstring) {
                        tooltipContent += `<span class="docstring">${info.docstring}</span><br>`;
                    }
                }
            }
            else if (d.docstring) {
                tooltipContent += `<br><span class="docstring">${d.docstring}</span><br>`;
            }
            if (d.metrics) {
                tooltipContent += '<br><strong>Metrics:</strong><br>';
                for (let [key, value] of Object.entries(d.metrics)) {
                    if (key === 'complexity') {
                        tooltipContent += `Cyclomatic Complexity: ${value}`;
                        if (value > 10) tooltipContent += ' ⚠️';
                        tooltipContent += '<br>';
                    }
                    else if (key === 'cognitive_complexity') {
                        tooltipContent += `Cognitive Complexity: ${value}`;
                        if (value > 15) tooltipContent += ' ⚠️';
                        tooltipContent += '<br>';
                    }
                    else if (key === 'lines') {
                        tooltipContent += `Lines: ${value}<br>`;
                    }
                }
            }

            if (d.code_smells && d.code_smells.length > 0) {
                tooltipContent += '<br><strong>Issues:</strong><br>';
                d.code_smells.forEach(smell => {
                    tooltipContent += `• ${smell}<br>`;
                });
            }

            if (connections.length > 0) {
                tooltipContent += '<br><strong>Connections:</strong><br>';
                connections.forEach(c => {
                    if (c.source.id === d.id) {
                        tooltipContent += `→ ${c.target.name} (${c.type})<br>`;
                    } else {
                        tooltipContent += `← ${c.source.name} (${c.type})<br>`;
                    }
                });
            }

            tooltip.html(tooltipContent)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");

            node.style("opacity", n =>
                n.id === d.id ||
                connections.some(c => c.source.id === n.id || c.target.id === n.id) ? 1 : 0.1
            );
            link.style("opacity", l =>
                l.source.id === d.id || l.target.id === d.id ? 1 : 0.1
            );
        })
        .on("mouseout", function() {
            tooltip.transition()
                .duration(500)
                .style("opacity", 0);
            node.style("opacity", 1);
            link.style("opacity", 0.7);
        });

        simulation
            .nodes(data.nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(data.links);

        simulation.force("collision", d3.forceCollide().radius(d => {
            const textWidth = d.name.length * 5;
            return Math.max(getNodeSize(d) + textWidth/2, 40);
        }).strength(1));



        window.addEventListener("resize", () => {
            width = window.innerWidth;
            height = window.innerHeight;
            svg.attr("width", width).attr("height", height);
            simulation.force("center", d3.forceCenter(width / 2, height / 2));
            simulation.alpha(1).restart();
        });

    </script>
</body>
</html>
